#!/bin/sh

# DESCRIPTION
#   This script migrates from "apt-key" managed keys to "[signed-by=.../keyrings/...]":
#    - loop through all lists in /etc/apt/sources.list.d
#      - read all lines with "deb..." that do not contain "[signed-by=]"
#      - download the GPG signature from the URL
#        - read the key ID from the signature
#        - download and save the key using gpg
#      - add "[signed-by=/usr/share/keyrings/...]" to the "deb..." line
#    - make a backup of the old .list file as .list.apt-key.bak
#
# USAGE
#   See --help.
#
# REQUIREMENTS
#   perl, curl, gpg
#
# CAVEATS
#   This does not work e.g. for Anydesk as the Ubuntu keyserver returns an expired key.
#   But you can manually download the ASCII armored key and then run migrate-apt-keys.sh:
#     curl https://keys.anydesk.com/repos/DEB-GPG-KEY | gpg --dearmor >/usr/share/keyrings/anydesk-stable-archive-keyring.gpg
#   See: https://lists.ubuntu.com/archives/ubuntu-users/2022-January/306500.html
#
# AUTHORS
#   Jens Berthold (https://github.com/maxhq); original GitHub gist: https://gist.github.com/maxhq/7dadf55064aaadc4d9e5993f89fad7b0
#   Alin Mr (https://github.com/mralusw)

set -ue

newline='
'

keyrings=/usr/local/share/keyrings

eecho() {
  printf '%s\n' "$*"
}

case "${1:-}" in (-h|--help)
  cat <<EOF
Args: [ KEYRING_FOLDER [SOURCE.list]... ]
Defaults:
  KEYRING_FOLDER=$keyrings
  SOURCE=( /etc/apt/sources.list /etc/apt/sources.list.d/*.list )

Before migrating, back up KEYRING_FOLDER, as well as SOURCEs. Files therein
will be modified. After migrating, check if 'apt update' works, then delete
(or better rename) '/etc/apt/trusted.gpg.d' and '/etc/apt/trusted.gpg'.
EOF
  exit 0
esac

workdir=$(cd "${TMPDIR:-/tmp}"; printf '%s/' "$PWD"; mktemp -d migrate.XXXXXX)
cleanup() {
  set +e
  trap - EXIT PIPE INT TERM QUIT
  rm -rf "$workdir"
}
trap 'cleanup' EXIT
trap 'cleanup; exit 1' PIPE INT TERM QUIT

if [ "$#" != 0 ]; then
  keyrings=$1
  shift
fi
mkdir -p "$keyrings"
if [ "$#" = 0 ]; then set -- /etc/apt/sources.list /etc/apt/sources.list.d/*.list; fi

url_key_map=$newline

for repo; do
  test -f "$repo" || continue
  sig_base=${repo##*/}; sig_base=${sig_base%.list}; sig_base=${sig_base%.list.*}
  sig_file=$keyrings/$sig_base-apt-keyring.gpg
  sig_keys=' '
  new_repo=$workdir/new_repo.list; : >"$new_repo"
  now_secs=$(date '+%s')

  while read -r line; do

    case "$line" in
      (deb-src*|deb*) ;;
      (*) eecho "$line" >>"$new_repo"; continue ;  # unmodified if no repo definition
    esac
    # skip if already "signed-by"
    case "$line" in
      (*'['*signed-by*']'*) eecho "$line" >>"$new_repo"; continue ;;
    esac

    eecho "$sig_base: += $line"

    # assemble URL
    url=$(eecho "$line" | perl -pe 's{^ (?:(?:deb|deb-src) \s+) (?: \[[^\]]+] \s+)? (\S+?)/? \s+ (\S+) \s+ .* }{ $suite=$2; "$1/".($suite=~m|/$|?$suite:"dists/$2/") }xe')

    if [ -z "${url_key_map##*$newline$url *}" ]; then
      keyid=${url_key_map##*$newline$url }; keyid=${keyid%%$newline*}
    else
      eecho "$sig_base: downloading $url"
      # download signature
      if ! sigfile=$(curl -s -f -L "${url}InRelease"); then
        if ! sigfile=$(curl -s -f -L "${url}Release.gpg"); then
          eecho "$sig_base: URL ${url}[InRelease|Release.gpg] not found"; exit 1
        fi
      fi

      # read key ID from signature
      keyid=$(eecho "$sigfile" | gpg --verify -vv 2>&1 | tr '\n' ' ' | perl -pe 's{.*signature.*keyid ([0-9A-Z]+).*}{$1}i')
      if [ -z "$keyid" ]; then eecho "$sig_base: Could not find key id in signature"; exit 1; fi
      eecho "$sig_base: key id = $keyid"
      url_key_map="$newline$url $keyid$url_key_map"
    fi

    if [ -n "$keyid" ] && [ -n "${sig_keys##* $keyid *}" ]; then
      # download key
      gpg --quiet --no-default-keyring --keyring gnupg-ring:"$sig_file" --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys "$keyid"
      expiry=$(gpg --no-default-keyring --keyring="$sig_file" --list-keys --with-colons --fixed-list-mode | keyid=$keyid perl -wne 'if (/^(pub|sub):.*:$ENV{keyid}:/) { my @f = split /:/; print "$f[6]\n" }')
      if [ -n "$expiry" ] && [ "$expiry" -lt "$now_secs" ]; then
        eecho "$sig_base: key $keyid expired on $(date -d "1970-01-01 UTC $expiry seconds" +"%Y-%m-%d %T %z")"
      fi
      sig_keys=" $keyid$sig_keys"
      chmod 0644 "$sig_file"
    fi

    eecho "$line" |
     sig_file=$sig_file perl >>"$new_repo" -pe 's{
  ^ ((?:deb|deb-src) \s+) (?: \[ ([^\]]+) ] \s+ )? (.*)
}{$1\[$2 signed-by=$ENV{sig_file}\] $3}x'

  done <"$repo"  # while read...

  rm -f "${sig_file}~"
  if ! cmp "$repo" "$new_repo" >/dev/null 2>&1; then
    cp "$repo" "$repo.apt-key.bak"
    # preserve permissions
    cat "$new_repo" >"$repo"
    eecho "$sig_base: migration done"
  else
    eecho "$sig_base: unchanged"
  fi
done  # for repo...

rm -rf "$workdir"
